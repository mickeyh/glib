project('glib', 'c', 'cpp',
  version : '2.51.0',
  meson_version : '>= 0.32.0',
  default_options : [ 'warning_level=1',
                      'c_std=gnu89',
                      'buildtype=debugoptimized' ])

cc = meson.get_compiler('c')
cxx = meson.get_compiler('cpp')

if cc.get_id() == 'msvc'
  # Ignore several spurious warnings for things glib does very commonly
  # If a warning is completely useless and spammy, use '/wdXXXX' to suppress it
  # If a warning is harmless but hard to fix, use '/woXXXX' so it's shown once
  # NOTE: Only add warnings here if you are sure they're spurious
  add_global_arguments('/wd4244', '/wd4305', '/wd4035', '/wd4715', '/wd4116',
    '/wd4046', '/wd4068', '/wo4090', language : 'c')
  # Disable SAFESEH with MSVC for plugins and libs that use external deps that
  # are built with MinGW
  noseh_link_args = ['/SAFESEH:NO']
else
  noseh_link_args = []
  # -mms-bitfields vs -fnative-struct ?
endif

host_system = host_machine.system()

#add_global_arguments('-Werror', language : 'c') # FIXME

glib_version = meson.project_version()
version_arr = glib_version.split('.')
major_version = version_arr[0]
minor_version = version_arr[1]
micro_version = version_arr[2]

soversion = 0
# Maintain compatibility with previous libtool versioning
# current = minor * 100 + micro
library_version = '@0@.@1@.0'.format(soversion, minor_version.to_int() * 100 + micro_version.to_int())

configinc = include_directories('.')
glibinc = include_directories('glib')
gobjectinc = include_directories('gobject')
gmoduleinc = include_directories('gmodule')
gioinc = include_directories('gio')

glib_prefix = get_option('prefix')
glib_libdir = glib_prefix + '/' + get_option('libdir')
glib_datadir = glib_prefix + '/' + get_option('datadir')
glib_pkgdatadir = glib_datadir + '/glib-2.0'
glib_includedir = glib_prefix + '/' + get_option('includedir')
glib_giomodulesdir = glib_libdir + '/gio/modules'

glib_pkgconfigreldir = get_option('libdir') + '/pkgconfig'

########################
# Configuration begins #
########################
glib_conf = configuration_data()
glibconfig_conf = configuration_data()

# accumulated list of defines as we check for them, so we can easily
# use them later in test programs (autoconf does this automatically)
glib_conf_prefix = ''

glib_conf.set('GLIB_VERSION', glib_version)
glib_conf.set('GLIB_MAJOR_VERSION', major_version)
glib_conf.set('GLIB_MINOR_VERSION', minor_version)
glib_conf.set('GLIB_MICRO_VERSION', micro_version)
glib_conf.set('GLIB_INTERFACE_AGE', micro_version)
glib_conf.set('GLIB_BINARY_AGE', 100 * minor_version.to_int() + micro_version.to_int())
glib_conf.set('GETTEXT_PACKAGE', '"glib20"')
glib_conf.set('PACKAGE_BUGREPORT', '"http://bugzilla.gnome.org/enter_bug.cgi?product=glib"')
glib_conf.set('PACKAGE_NAME', '"glib"')
glib_conf.set('PACKAGE_STRING', '"glib @0@"'.format(meson.project_version()))
glib_conf.set('PACKAGE_TARNAME', '"glib"')
glib_conf.set('PACKAGE_URL', '""')
glib_conf.set('PACKAGE_VERSION', '"@0@"'.format(meson.project_version()))
glib_conf.set('ENABLE_NLS', 1)
glib_conf.set('HAVE_GOOD_PRINTF', 1) # FIXME

# Variables used in glib-gettextize and pkg-config files
# These should not contain " quotes around the values
glib_conf.set('PACKAGE', 'glib')
glib_conf.set('VERSION', meson.project_version())
glib_conf.set('prefix', glib_prefix)
glib_conf.set('exec_prefix', glib_prefix)
glib_conf.set('libdir', glib_libdir)
glib_conf.set('includedir', glib_includedir)
glib_conf.set('datadir', glib_datadir)
glib_conf.set('datarootdir', glib_datadir)

glib_conf.set('_GNU_SOURCE', 1)

if host_system == 'windows'
  # Poll doesn't work on devices on Windows
  glib_conf.set('BROKEN_POLL', true)
endif

# Detect and set symbol visibility
if get_option('default_library') != 'static'
  if host_system == 'windows'
    glib_conf.set('DLL_EXPORT', true)
    if cc.get_id() == 'msvc'
      glib_conf.set('_GLIB_EXTERN', '__declspec(dllexport) extern')
    else
      glib_conf.set('_GLIB_EXTERN', '__attribute__((visibility("default"))) __declspec(dllexport) extern')
      add_global_arguments('-fvisibility=hidden', language : 'c')
    endif
  else
    glib_conf.set('_GLIB_EXTERN', '__attribute__((visibility("default"))) extern')
    add_global_arguments('-fvisibility=hidden', language : 'c')
  endif
endif

if run_command('xgettext', '--help').returncode() != 0
  error('GNU Gettext required currently.')
endif
glib_conf.set('HAVE_GETTEXT', 1)
glib_conf.set('GLIB_LOCALE_DIR', '"@0@/share/locale"'.format(get_option('prefix')))

# FIXME: what about Cygwin (G_WITH_CYGWIN)
if host_system == 'windows'
  glib_os = '''#define G_OS_WIN32
#define G_PLATFORM_WIN32'''
else
  glib_os = '#define G_OS_UNIX'
endif
glibconfig_conf.set('glib_os', glib_os)

# check for header files

headers = [
  ['stdlib.h', 'HAVE_STDLIB_H'],
  ['string.h', 'HAVE_STRING_H'],
  ['strings.h', 'HAVE_STRINGS_H'],
  ['memory.h', 'HAVE_MEMORY_H'],
  ['alloca.h', 'HAVE_ALLOCA_H'],
  ['locale.h', 'HAVE_LOCALE_H'],
  ['xlocale.h', 'HAVE_XLOCALE_H'],
  ['float.h', 'HAVE_FLOAT_H'],
  ['limits.h', 'HAVE_LIMITS_H'],
  ['pwd.h', 'HAVE_PWD_H'],
  ['grp.h', 'HAVE_GRP_H'],
  ['poll.h', 'HAVE_POLL_H'],
  ['sys/param.h', 'HAVE_SYS_PARAM_H'],
  ['sys/resource.h', 'HAVE_SYS_RESOURCE_H'],
  ['mach/mach_time.h', 'HAVE_MACH_MACH_TIME_H'],
  ['sys/select.h', 'HAVE_SYS_SELECT_H'],
  ['stdint.h', 'HAVE_STDINT_H'],
  ['inttypes.h', 'HAVE_INTTYPES_H'],
  ['sched.h', 'HAVE_SCHED_H'],
  ['malloc.h', 'HAVE_MALLOC_H'],
  ['sys/vfs.h', 'HAVE_SYS_VFS_H'],
  ['sys/vmount.h', 'HAVE_SYS_VMOUNT_H'],
  ['sys/statfs.h', 'HAVE_SYS_STATFS_H'],
  ['sys/statvfs.h', 'HAVE_SYS_STATVFS_H'],
  ['sys/filio.h', 'HAVE_SYS_FILIO_H'],
  ['mntent.h', 'HAVE_MNTENT_H'],
  ['sys/mnttab.h', 'HAVE_SYS_MNTTAB_H'],
  ['sys/vfstab.h', 'HAVE_SYS_VFSTAB_H'],
  ['sys/mntctl.h', 'HAVE_SYS_mntctl_H'],
  ['fstab.h', 'HAVE_FSTAB_H'],
  ['linux/magic.h', 'HAVE_LINUX_MAGIC_H'],
  ['sys/prctl.h', 'HAVE_SYS_PRCTL_H'],
  ['dirent.h', 'HAVE_DIRENT_H'], # Some versions of MSC lack these
  ['sys/time.h', 'HAVE_SYS_TIME_H'], # Some versions of MSC lack these
  ['sys/times.h', 'HAVE_SYS_TIMES_H'],
  ['sys/wait.h', 'HAVE_SYS_WAIT_H'],
  ['unistd.h', 'HAVE_UNISTD_H'],
  ['values.h', 'HAVE_VALUES_H'],
  ['sys/types.h', 'HAVE_SYS_TYPES_H'],
  ['sys/uio.h', 'HAVE_SYS_UIO_H'],
  ['sys/mkdev.h', 'HAVE_SYS_MKDEV_H'],
  ['sys/mount.h', 'HAVE_SYS_MOUNT_H'],
  ['sys/sysctl.h', 'HAVE_SYS_SYSCTL_H'],
  ['crt_externs.h', 'HAVE_CRT_EXTERNS_H'],
  ['linux/netlink.h', 'HAVE_NETLINK'],
  ['sys/inotify.h', 'HAVE_SYS_INOTIFY_H'],
  ['sys/event.h', 'HAVE_SYS_EVENT_H'],
  ['sys/stat.h', 'HAVE_SYS_STAT_H'],
]

foreach h : headers
  if cc.has_header(h[0])
    glib_conf.set(h[1], 1)
    glib_conf_prefix = glib_conf_prefix + '#define @0@ 1\n'.format(h[1])
  endif
endforeach

if glib_conf.has('HAVE_LOCALE_H')
  if cc.has_header_symbol('locale.h', 'LC_MESSAGES')
    glib_conf.set('HAVE_LC_MESSAGES', 1)
  endif
endif

struct_stat_blkprefix = '''
#include <sys/types.h>
#include <sys/stat.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_SYS_STATFS_H
#include <sys/statfs.h>
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif
'''

struct_members = [
  [ 'stat', 'st_mtimensec', 'HAVE_STRUCT_STAT_ST_MTIMENSEC' ],
  [ 'stat', 'st_mtim.tv_nsec', 'HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC' ],
  [ 'stat', 'st_atimensec', 'HAVE_STRUCT_STAT_ST_ATIMENSEC' ],
  [ 'stat', 'st_atim.tv_nsec', 'HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC' ],
  [ 'stat', 'st_ctimensec', 'HAVE_STRUCT_STAT_ST_CTIMENSEC' ],
  [ 'stat', 'st_ctim.tv_nsec', 'HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC' ],
  [ 'stat', 'st_birthtime', 'HAVE_STRUCT_STAT_ST_BIRTHTIME' ],
  [ 'stat', 'st_birthtimensec', 'HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC' ],
  [ 'stat', 'st_birthtim', 'HAVE_STRUCT_STAT_ST_BIRTHTIM' ],
  [ 'stat', 'st_birthtim.tv_nsec', 'HAVE_STRUCT_STAT_ST_BIRTHTIME_TV_NSEC' ],
  [ 'stat', 'st_blksize', 'HAVE_STRUCT_STAT_ST_BLKSIZE', struct_stat_blkprefix ],
  [ 'stat', 'st_blocks', 'HAVE_STRUCT_STAT_ST_BLOCKS', struct_stat_blkprefix ],
  [ 'statfs', 'f_fstypename', 'HAVE_STRUCT_STATFS_F_FSTYPENAME', struct_stat_blkprefix ],
  [ 'statfs', 'f_bavail', 'HAVE_STRUCT_STATFS_F_BAVAIL', struct_stat_blkprefix ],
  [ 'dirent', 'd_type', 'HAVE_STRUCT_DIRENT_D_TYPE', '''#include <sys/types.h>
                                                        #include <dirent.h>''' ],
]

foreach m : struct_members
  header_check_prefix = glib_conf_prefix
  if m.length() == 4
    header_check_prefix = header_check_prefix + m[3]
  else
    header_check_prefix = header_check_prefix + '#include <sys/stat.h>'
  endif
  if cc.has_member('struct ' + m[0], m[1], prefix : header_check_prefix)
    glib_conf.set(m[2], 1)
    glib_conf_prefix = glib_conf_prefix + '#define @0@ 1\n'.format(m[2])
  else
  endif
endforeach

functions = [
  ['alloca', 'HAVE_ALLOCA'],
  ['mmap', 'HAVE_MMAP'],
  ['posix_memalign', 'HAVE_POSIX_MEMALIGN'],
  ['memalign', 'HAVE_MEMALIGN'],
  ['valloc', 'HAVE_VALLOC'],
  ['fsync', 'HAVE_FSYNC'],
  ['pipe2', 'HAVE_PIPE2'],
  ['issetugid', 'HAVE_ISSETUGID'],
  ['timegm', 'HAVE_TIMEGM'],
  ['gmtime_r', 'HAVE_GMTIME_R'],
  ['strerror_r', 'HAVE_STRERROR_R'],
  ['lstat', 'HAVE_LSTAT'],
  ['strsignal', 'HAVE_STRSIGNAL'],
  ['vsnprintf', 'HAVE_VSNPRINTF'],
  ['stpcpy', 'HAVE_STPCPY'],
  ['poll', 'HAVE_POLL'],
  ['vasprintf', 'HAVE_VASPRINTF'],
  ['setenv', 'HAVE_SETENV'],
  ['unsetenv', 'HAVE_UNSETENV'],
  ['getc_unlocked', 'HAVE_GETC_UNLOCKED'],
  ['readlink', 'HAVE_READLINK'],
  ['symlink', 'HAVE_SYMLINK'],
  ['fdwalk', 'HAVE_FDWALK'],
  ['memmem', 'HAVE_MEMMEM'],
  ['lchmod', 'HAVE_LCHMOD'],
  ['lchown', 'HAVE_LCHOWN'],
  ['fchmod', 'HAVE_FCHMOD'],
  ['fchown', 'HAVE_FCHOWN'],
  ['utimes', 'HAVE_UTIMES'],
  ['getresuid', 'HAVE_GETRESUID'],
  ['getmntent_r', 'HAVE_GETMNTENT_R'],
  ['setmntent', 'HAVE_SETMNTENT'],
  ['endmntent', 'HAVE_ENDMNTENT'],
  ['hasmntopt', 'HAVE_HASMNTOPT'],
  ['getfsstat', 'HAVE_GETFSSTAT'],
  ['getvfsstat', 'HAVE_GETVFSSTAT'],
  ['fallocate', 'HAVE_FALLOCATE'],
  ['localtime_r', 'HAVE_LOCALTIME_R'],
  ['gmtime_r', 'HAVE_GMTIME_R'],
  ['getpwuid_r', 'HAVE_GETPWUID_R'],
  ['getgrgid_r', 'HAVE_GETGRGID_R'],
  ['prlimit', 'HAVE_PRLIMIT'],
  ['strnlen', 'HAVE_STRNLEN'],
  ['wcslen', 'HAVE_WCSLEN'],
  ['wcsnlen', 'HAVE_WCSNLEN'],
  ['mbrtowc', 'HAVE_MBRTOWC'],
  ['wcrtomb', 'HAVE_WCRTOMB'],
  ['newlocale', 'HAVE_NEWLOCALE'],
  ['uselocale', 'HAVE_USELOCALE'],
  ['strtod_l', 'HAVE_STRTOD_L'],
  ['strtoll_l', 'HAVE_STRTOLL_L'],
  ['strtoull_l', 'HAVE_STRTOULL_L'],
  ['inotify_init1', 'HAVE_INOTIFY_INIT1'],
  ['kqueue', 'HAVE_KQUEUE'],
  ['kevent', 'HAVE_KEVENT'],
  ['getservent', 'HAVE_GETSERVENT'],
  ['getprotobyname_r', 'HAVE_GETPROTOBYNAME_R'],
  ['if_indextoname', 'HAVE_IF_INDEXTONAME'],
  ['if_nametoindex', 'HAVE_IF_NAMETOINDEX'],
  ['sendmmsg', 'HAVE_SENDMMSG'],
  ['recvmmsg', 'HAVE_RECVMMSG'],
]

if glib_conf.has('HAVE_SYS_STATVFS_H')
  functions += [['statvfs', 'HAVE_STATVFS']]
else
  have_func_statvfs = false
endif
if glib_conf.has('HAVE_SYS_STATFS_H') or glib_conf.has('HAVE_SYS_MOUNT_H')
  functions += [['statfs', 'HAVE_STATFS']]
else
  have_func_statfs = false
endif

# AIX splice is something else
if host_system != 'aix'
  functions += [
    [ 'splice', 'HAVE_SPLICE' ]
  ]
endif

foreach f : functions
  if cc.has_function(f[0])
    glib_conf.set(f[1], 1)
    glib_conf_prefix = glib_conf_prefix + '#define @0@ 1\n'.format(f[1])
    set_variable('have_func_' + f[0], true)
  else
    set_variable('have_func_' + f[0], false)
  endif
endforeach

# Special-case these functions that have alternative names on Windows/MSVC
if cc.has_function('snprintf') or cc.has_header_symbol('stdio.h', 'snprintf')
  glib_conf.set('HAVE_SNPRINTF', 1)
  glib_conf_prefix = glib_conf_prefix + '#define HAVE_SNPRINTF 1\n'
elif cc.has_function('_snprintf') or cc.has_header_symbol('stdio.h', '_snprintf')
  hack_define = '1\n#define snprintf _snprintf'
  glib_conf.set('HAVE_SNPRINTF', hack_define)
  glib_conf_prefix = glib_conf_prefix + '#define HAVE_SNPRINTF ' + hack_define
endif

if cc.has_function('strcasecmp')
  glib_conf.set('HAVE_STRCASECMP', 1)
  glib_conf_prefix = glib_conf_prefix + '#define HAVE_STRCASECMP 1\n'
elif cc.has_function('_stricmp')
  hack_define = '1\n#define strcasecmp _stricmp'
  glib_conf.set('HAVE_STRCASECMP', hack_define)
  glib_conf_prefix = glib_conf_prefix + '#define HAVE_STRCASECMP ' + hack_define
endif

if cc.has_function('strncasecmp')
  glib_conf.set('HAVE_STRNCASECMP', 1)
  glib_conf_prefix = glib_conf_prefix + '#define HAVE_STRNCASECMP 1\n'
elif cc.has_function('_strnicmp')
  hack_define = '1\n#define strncasecmp _strnicmp'
  glib_conf.set('HAVE_STRNCASECMP', hack_define)
  glib_conf_prefix = glib_conf_prefix + '#define HAVE_STRNCASECMP ' + hack_define
endif

# Check whether to use statfs or statvfs
# Some systems have both statfs and statvfs, pick the most "native" for these
if have_func_statfs and have_func_statvfs
  # on solaris and irix, statfs doesn't even have the f_bavail field
  if not glib_conf.has('HAVE_STRUCT_STATFS_F_BAVAIL')
    have_func_statfs = false
  else
    # at least on linux, statfs is the actual syscall
    have_func_statvfs = false
  endif
endif
if have_func_statfs
  glib_conf.set('USE_STATFS', 1)
  stat_func_to_use = 'statfs'
elif have_func_statvfs
  glib_conf.set('USE_STATVFS', 1)
  stat_func_to_use = 'statvfs'
else
  stat_func_to_use = 'neither'
endif
message('Checking whether to use statfs or statvfs .. ' + stat_func_to_use)

# Mac OS X Carbon support
glib_have_carbon = cc.compiles('''#include <Carbon/Carbon.h>
                                  #include <CoreServices/CoreServices.h>''',
                               name : 'Mac OS X Carbon support')

if glib_have_carbon
  glib_conf.set('HAVE_CARBON', true)
  CARBON_LIBS='-Wl,-framework,Carbon' # FIXME: propagate to .pc files as well
else
  CARBON_LIBS=''
endif

# Check for futex(2)
if cc.links('''#include <linux/futex.h>
               #include <sys/syscall.h>
               #include <unistd.h>
               int main (int argc, char ** argv) {
                 syscall (__NR_futex, NULL, FUTEX_WAKE, FUTEX_WAIT);
                 return 0;
               }''', name : 'futex(2) system call')
  glib_conf.set('HAVE_FUTEX', 1)
endif

# Check for eventfd(2)
if cc.links('''#include <sys/eventfd.h>
               #include <unistd.h>
               int main (int argc, char ** argv) {
                 eventfd (0, EFD_CLOEXEC);
                 return 0;
               }''', name : 'eventfd(2) system call')
  glib_conf.set('HAVE_EVENTFD', 1)
endif

clock_gettime_test_code = '''
  #include <time.h>
  struct timespec t;
  int main (int argc, char ** argv) {
    return clock_gettime(CLOCK_REALTIME, &t);
  }'''
librt = []
if cc.links(clock_gettime_test_code, name : 'clock_gettime')
  glib_conf.set('HAVE_CLOCK_GETTIME', 1)
elif cc.links(clock_gettime_test_code, args : '-lrt', name : 'clock_gettime in librt')
  glib_conf.set('HAVE_CLOCK_GETTIME', 1)
  librt = cc.find_library('rt')
endif

# if statfs() takes 2 arguments (Posix) or 4 (Solaris)
if have_func_statfs
  if cc.compiles(glib_conf_prefix + '''
                 #include <unistd.h>
                        #ifdef HAVE_SYS_PARAM_H
                        #include <sys/param.h>
                        #endif
                        #ifdef HAVE_SYS_VFS_H
                        #include <sys/vfs.h>
                        #endif
                        #ifdef HAVE_SYS_MOUNT_H
                        #include <sys/mount.h>
                        #endif
                        #ifdef HAVE_SYS_STATFS_H
                        #include <sys/statfs.h>
                        #endif
                        void some_func (void) {
                          struct statfs st;
                          statfs(NULL, &st);
                        }''', name : 'number of arguments to statfs() (n=2)')
    glib_conf.set('STATFS_ARGS', 2)
  elif cc.compiles(glib_conf_prefix + '''
                   #include <unistd.h>
                          #ifdef HAVE_SYS_PARAM_H
                          #include <sys/param.h>
                          #endif
                          #ifdef HAVE_SYS_VFS_H
                          #include <sys/vfs.h>
                          #endif
                          #ifdef HAVE_SYS_MOUNT_H
                          #include <sys/mount.h>
                          #endif
                          #ifdef HAVE_SYS_STATFS_H
                          #include <sys/statfs.h>
                          #endif
                          void some_func (void) {
                            struct statfs st;
                            statfs(NULL, &st, sizeof (st), 0);
                          }''', name : 'number of arguments to statfs() (n=4)')
    glib_conf.set('STATFS_ARGS', 4)
  else
    error('Unable to determine number of arguments to statfs()')
  endif
endif

# open takes O_DIRECTORY as an option
#AC_MSG_CHECKING([])
if cc.compiles('''#include <fcntl.h>
                  #include <sys/types.h>
                  #include <sys/stat.h>],
                  void some_func (void) {
                    open(0, O_DIRECTORY, 0);
                  }''', name : 'open() option O_DIRECTORY')
  glib_conf.set('HAVE_OPEN_O_DIRECTORY', 1)
endif

# Check whether there is a vsnprintf() function with C99 semantics installed.
# AC_FUNC_VSNPRINTF_C99
# Check whether there is a snprintf() function with C99 semantics installed.
# AC_FUNC_SNPRINTF_C99
if host_system == 'windows' and cc.get_id() == 'gcc'
  # Unfortunately the mingw implementations of C99-style snprintf and vsnprintf
  # don't seem to be quite good enough, at least not in mingw-runtime-3.14.
  # (Sorry, I don't know exactly what is the problem, but it is related to
  # floating point formatting and decimal point vs. comma.)
  # The simple tests in AC_FUNC_VSNPRINTF_C99 and AC_FUNC_SNPRINTF_C99 aren't
  # rigorous enough to notice, though.
  glib_conf.set('HAVE_C99_SNPRINTF', false)
  glib_conf.set('HAVE_C99_VSNPRINTF', false)
else
  vsnprintf_c99_test_code = '''
#include <stdio.h>
#include <stdarg.h>

int
doit(char * s, ...)
{
  char buffer[32];
  va_list args;
  int r;

  va_start(args, s);
  r = vsnprintf(buffer, 5, s, args);
  va_end(args);

  if (r != 7)
    exit(1);

  /* AIX 5.1 and Solaris seems to have a half-baked vsnprintf()
     implementation. The above will return 7 but if you replace
     the size of the buffer with 0, it borks! */
  va_start(args, s);
  r = vsnprintf(buffer, 0, s, args);
  va_end(args);

  if (r != 7)
    exit(1);

  exit(0);
}

int
main(void)
{
  doit("1234567");
  exit(1);
}'''

  rres = cc.run(vsnprintf_c99_test_code, name : 'C99 vsnprintf')
  if rres.compiled() and rres.returncode() == 0
    glib_conf.set('HAVE_C99_VSNPRINTF', 1)
  endif

  snprintf_c99_test_code = '''
#include <stdio.h>
#include <stdarg.h>

int
doit()
{
  char buffer[32];
  va_list args;
  int r;

  r = snprintf(buffer, 5, "1234567");

  if (r != 7)
    exit(1);

  r = snprintf(buffer, 0, "1234567");

  if (r != 7)
    exit(1);

  r = snprintf(NULL, 0, "1234567");

  if (r != 7)
    exit(1);

  exit(0);
}

int
main(void)
{
  doit();
  exit(1);
}'''

  rres = cc.run(snprintf_c99_test_code, name : 'C99 snprintf')
  if rres.compiled() and rres.returncode() == 0
    glib_conf.set('HAVE_C99_SNPRINTF', 1)
  endif
endif

if host_system == 'windows'
  glib_conf.set('EXEEXT', '".exe"')
else
  glib_conf.set('EXEEXT', '""')
endif

# Check whether the printf() family supports Unix98 %n$ positional parameters 
# AC_FUNC_PRINTF_UNIX98
# Nothing uses HAVE_UNIX98_PRINTF

glib_conf.set('HAVE_DCGETTEXT', cc.has_header_symbol('libintl.h', 'dcgettext'))

# Check for nl_langinfo and CODESET
# FIXME: Check for HAVE_BIND_TEXTDOMAIN_CODESET
if cc.links('''#include <langinfo.h>
               int main (int argc, char ** argv) {
                 char *codeset = nl_langinfo (CODESET);
                 return 0;
               }''', name : 'nl_langinfo and CODESET')
  glib_conf.set('HAVE_LANGINFO_CODESET', 1)
  glib_conf.set('HAVE_CODESET', 1)
endif

# Check for nl_langinfo and LC_TIME parts that are needed in gdatetime.c
if cc.links('''#include <langinfo.h>
               int main (int argc, char ** argv) {
                 char *str;
                 str = nl_langinfo (PM_STR);
                 str = nl_langinfo (D_T_FMT);
                 str = nl_langinfo (D_FMT);
                 str = nl_langinfo (T_FMT);
                 str = nl_langinfo (T_FMT_AMPM);
                 str = nl_langinfo (MON_1);
                 str = nl_langinfo (ABMON_12);
                 str = nl_langinfo (DAY_1);
                 str = nl_langinfo (ABDAY_7);
                 return 0;
               }''', name : 'nl_langinfo (PM_STR)')
  glib_conf.set('HAVE_LANGINFO_TIME', 1)
endif
if cc.links('''#include <langinfo.h>
               int main (int argc, char ** argv) {
                 char *str;
                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT0_MB);
                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT1_MB);
                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT2_MB);
                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT3_MB);
                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT4_MB);
                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT5_MB);
                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT6_MB);
                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT7_MB);
                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT8_MB);
                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT9_MB);
                 return 0;
               }''', name : 'nl_langinfo (_NL_CTYPE_OUTDIGITn_MB)')
  glib_conf.set('HAVE_LANGINFO_OUTDIGIT', 1)
endif

# Check if C compiler supports the 'signed' keyword
if not cc.compiles('''signed char x;''', name : 'signed')
  glib_conf.set('signed', '/* NOOP */')
endif

# Check if the ptrdiff_t type exists
if cc.has_header_symbol('stddef.h', 'ptrdiff_t')
  glib_conf.set('HAVE_PTRDIFF_T', 1)
endif

# Check for sig_atomic_t type
if cc.links('''#include <signal.h>
               #include <sys/types.h>
               sig_atomic_t val = 42;
               int main (int argc, char ** argv) {
                 return val == 42 ? 0 : 1;
               }''', name : 'sig_atomic_t')
  glib_conf.set('HAVE_SIG_ATOMIC_T', 1)
endif

# Check if 'long long' works and what format can be used to print it
# jm_AC_TYPE_LONG_LONG
# Nothing uses HAVE_LONG_LONG_FORMAT and HAVE_INT64_AND_I64
if cc.compiles('''long long ll = 1LL;
                  int i = 63;
                  int some_func (void) {
                    long long llmax = (long long) -1;
                    return ll << i | ll >> i | llmax / ll | llmax % ll;
                  }''', name : 'long long')
  glib_conf.set('HAVE_LONG_LONG', 1)
  have_long_long = true
else
  have_long_long = false
endif

# Test whether the compiler supports the 'long double' type.
if cc.compiles('''/* The Stardent Vistra knows sizeof(long double), but does not support it.  */
                  long double foo = 0.0;
                  /* On Ultrix 4.3 cc, long double is 4 and double is 8.  */
                  int array [2*(sizeof(long double) >= sizeof(double)) - 1];''',
               name : 'long double')
  glib_conf.set('HAVE_LONG_DOUBLE', 1)
endif

#dnl Test whether <stddef.h> has the 'wchar_t' type.
if cc.has_header_symbol('stddef.h', 'wchar_t')
  glib_conf.set('HAVE_WCHAR_T', 1)
endif

# Test whether <wchar.h> has the 'wint_t' type.
if cc.has_header_symbol('wchar.h', 'wint_t')
  glib_conf.set('HAVE_WINT_T', 1)
endif

found_uintmax_t = false

# Define HAVE_INTTYPES_H_WITH_UINTMAX if <inttypes.h> exists,
# doesn't clash with <sys/types.h>, and declares uintmax_t.
# jm_AC_HEADER_INTTYPES_H
if cc.compiles('''#include <sys/types.h>
                  #include <inttypes.h>
                  void some_func (void) {
                    uintmax_t i = (uintmax_t) -1;
                  }''', name : 'uintmax_t in inttypes.h')
  glib_conf.set('HAVE_INTTYPES_H_WITH_UINTMAX', 1)
  found_uintmax_t = true
endif

# Define HAVE_STDINT_H_WITH_UINTMAX if <stdint.h> exists,
# doesn't clash with <sys/types.h>, and declares uintmax_t.
# jm_AC_HEADER_STDINT_H
if cc.compiles('''#include <sys/types.h>
                  #include <stdint.h>
                  void some_func (void) {
                    uintmax_t i = (uintmax_t) -1;
                  }''', name : 'uintmax_t in stdint.h')
  glib_conf.set('HAVE_STDINT_H_WITH_UINTMAX', 1)
  found_uintmax_t = true
endif

# Define intmax_t to 'long' or 'long long'
# if it is not already defined in <stdint.h> or <inttypes.h>.
# For simplicity, we assume that a header file defines 'intmax_t' if and
# only if it defines 'uintmax_t'.
if found_uintmax_t
  glib_conf.set('HAVE_INTMAX_T', 1)
elif have_long_long
  glib_conf.set('intmax_t', 'long long')
else
  glib_conf.set('intmax_t', 'long')
endif

char_size = cc.sizeof('char')
short_size = cc.sizeof('short')
int_size = cc.sizeof('int')
voidp_size = cc.sizeof('void*')
long_size = cc.sizeof('long')
if have_long_long
  long_long_size = cc.sizeof('long long')
else
  long_long_size = 0
endif
sizet_size = cc.sizeof('size_t')
if cc.get_id() == 'msvc'
  ssizet_size = cc.sizeof('SSIZE_T', prefix : '#include <BaseTsd.h>')
else
  ssizet_size = cc.sizeof('ssize_t')
endif

# On Windows, MSVC supports both ll and I64 as format specifiers for 64-bit
# integers, but some versions (at least 4.7.x) of MinGW only support I64.
if host_system == 'windows'
  int64_m = '"I64'
else
  int64_m = '"ll'
endif

char_align = cc.alignment('char')
short_align = cc.alignment('short')
int_align = cc.alignment('int')
voidp_align = cc.alignment('void*')
long_align = cc.alignment('long')
long_long_align = cc.alignment('long long')
# NOTE: We don't check for size of __int64 because long long is guaranteed to
# be 64-bit in C99, and it is available on all supported compilers
sizet_align = cc.alignment('size_t')

glib_conf.set('ALIGNOF_UNSIGNED_LONG', long_align)

glib_conf.set('SIZEOF_CHAR', char_size)
glib_conf.set('SIZEOF_INT', int_size)
glib_conf.set('SIZEOF_SHORT', short_size)
glib_conf.set('SIZEOF_LONG', long_size)
glib_conf.set('SIZEOF_LONG_LONG', long_long_size)
glib_conf.set('SIZEOF_SIZE_T', sizet_size)
glib_conf.set('SIZEOF_SSIZE_T', ssizet_size)
glib_conf.set('SIZEOF_VOID_P', voidp_size)

if short_size == 2
  gint16 = 'short'
  gint16_modifier='"h"'
  gint16_format='"hi"'
  guint16_format='"hu"'
elif int_size == 2
  gint16 = 'int'
  gint16_modifier='""'
  gint16_format='"i"'
  guint16_format='"u"'
else
  error('Compiler provides no native 16-bit integer type')
endif
glibconfig_conf.set('gint16', gint16)
glibconfig_conf.set('gint16_modifier', gint16_modifier)
glibconfig_conf.set('gint16_format', gint16_format)
glibconfig_conf.set('guint16_format', guint16_format)

if short_size == 4
  gint32 = 'short'
  gint32_modifier='"h"'
  gint32_format='"hi"'
  guint32_format='"hu"'
  guint32_align = short_align
elif int_size == 4
  gint32 = 'int'
  gint32_modifier='""'
  gint32_format='"i"'
  guint32_format='"u"'
  guint32_align = int_align
elif long_size == 4
  gint32 = 'long'
  gint32_modifier='"l"'
  gint32_format='"li"'
  guint32_format='"lu"'
  guint32_align = long_align
else
  error('Compiler provides no native 32-bit integer type')
endif
glibconfig_conf.set('gint32', gint32)
glibconfig_conf.set('gint32_modifier', gint32_modifier)
glibconfig_conf.set('gint32_format', gint32_format)
glibconfig_conf.set('guint32_format', guint32_format)
glib_conf.set('ALIGNOF_GUINT32', guint32_align)

if int_size == 8
  gint64 = 'int'
  gint64_modifier='""'
  gint64_format='"i"'
  guint64_format='"u"'
  glib_extension=''
  gint64_constant='(val)'
  guint64_constant='(val)'
  guint64_align = int_align
elif long_size == 8
  gint64 = 'long'
  glib_extension=''
  gint64_modifier='"l"'
  gint64_format='"li"'
  guint64_format='"lu"'
  gint64_constant='(val##L)'
  guint64_constant='(val##UL)'
  guint64_align = long_align
elif long_long_size == 8
  gint64 = 'long long'
  glib_extension=''
  gint64_modifier=int64_m + '"'
  gint64_format=int64_m + 'i"'
  guint64_format=int64_m + 'u"'
  gint64_constant='(val##LL)'
  guint64_constant='(val##ULL)'
  guint64_align = long_long_align
else
  error('Compiler provides no native 64-bit integer type')
endif
glibconfig_conf.set('gint64', gint64)
glibconfig_conf.set('gint64_modifier', gint64_modifier)
glibconfig_conf.set('gint64_format', gint64_format)
glibconfig_conf.set('guint64_format', guint64_format)
glibconfig_conf.set('gint64_constant', gint64_constant)
glibconfig_conf.set('guint64_constant', guint64_constant)
glib_conf.set('ALIGNOF_GUINT64', guint64_align)

if host_system == 'windows'
  glibconfig_conf.set('g_pid_type', 'void*')
  if host_machine.cpu_family() == 'x86_64'
    glibconfig_conf.set('g_pollfd_format', '"%#I64x"')
  else
    glibconfig_conf.set('g_pollfd_format', '"%#x"')
  endif
else
  glibconfig_conf.set('g_pid_type', 'int')
  glibconfig_conf.set('g_pollfd_format', '"%d"')
endif

if sizet_size == short_size
  glibconfig_conf.set('glib_size_type_define', 'short')
  glibconfig_conf.set('gsize_modifier', '"h"')
  glibconfig_conf.set('gssize_modifier', '"h"')
  glibconfig_conf.set('gsize_format', '"hu"')
  glibconfig_conf.set('gssize_format', '"hi"')
  glibconfig_conf.set('glib_msize_type', 'SHRT')
elif sizet_size == int_size
  glibconfig_conf.set('glib_size_type_define', 'int')
  glibconfig_conf.set('gsize_modifier', '""')
  glibconfig_conf.set('gssize_modifier', '""')
  glibconfig_conf.set('gsize_format', '"u"')
  glibconfig_conf.set('gssize_format', '"i"')
  glibconfig_conf.set('glib_msize_type', 'INT')
elif sizet_size == long_size
  glibconfig_conf.set('glib_size_type_define', 'long')
  glibconfig_conf.set('gsize_modifier', '"l"')
  glibconfig_conf.set('gssize_modifier', '"l"')
  glibconfig_conf.set('gsize_format', '"lu"')
  glibconfig_conf.set('gssize_format', '"li"')
  glibconfig_conf.set('glib_msize_type', 'LONG')
elif sizet_size == long_long_size
  glibconfig_conf.set('glib_size_type_define', 'long long')
  glibconfig_conf.set('gsize_modifier', int64_m + '"')
  glibconfig_conf.set('gssize_modifier', int64_m + '"')
  glibconfig_conf.set('gsize_format', int64_m + 'u"')
  glibconfig_conf.set('gssize_format', int64_m + 'i"')
  glibconfig_conf.set('glib_msize_type', 'INT64')
else
  error('Could not determine size of size_t.')
endif

if voidp_size == int_size
  glibconfig_conf.set('glib_intptr_type_define', 'int')
  glibconfig_conf.set('gintptr_modifier', '""')
  glibconfig_conf.set('gintptr_format', '"i"')
  glibconfig_conf.set('guintptr_format', '"u"')
  glibconfig_conf.set('glib_gpi_cast', '(gint)')
  glibconfig_conf.set('glib_gpui_cast', '(guint)')
elif voidp_size == long_size
  glibconfig_conf.set('glib_intptr_type_define', 'long')
  glibconfig_conf.set('gintptr_modifier', '"l"')
  glibconfig_conf.set('gintptr_format', '"li"')
  glibconfig_conf.set('guintptr_format', '"lu"')
  glibconfig_conf.set('glib_gpi_cast', '(glong)')
  glibconfig_conf.set('glib_gpui_cast', '(gulong)')
elif voidp_size == long_long_size
  glibconfig_conf.set('glib_intptr_type_define', 'long long')
  glibconfig_conf.set('gintptr_modifier', int64_m + '"')
  glibconfig_conf.set('gintptr_format', int64_m + 'i"')
  glibconfig_conf.set('guintptr_format', int64_m + 'u"')
  glibconfig_conf.set('glib_gpi_cast', '(gint64)')
  glibconfig_conf.set('glib_gpui_cast', '(guint64)')
else
  error('Could not determine size of void *')
endif

if long_size != 8 and long_long_size != 8 and int_size != 8
  error('GLib requires a 64-bit type. You might want to consider using the GNU C compiler.')
endif

glibconfig_conf.set('gintbits', int_size * 8)
glibconfig_conf.set('glongbits', long_size * 8)
glibconfig_conf.set('gsizebits', sizet_size * 8)
glibconfig_conf.set('gssizebits', ssizet_size * 8)

# FIXME: maybe meson should tell us the libsuffix?
if host_system == 'windows'
  g_module_suffix = 'dll'
elif host_system == 'darwin'
  g_module_suffix = 'dylib'
else
  g_module_suffix = 'so'
endif
glibconfig_conf.set('g_module_suffix', g_module_suffix)

glibconfig_conf.set('GLIB_MAJOR_VERSION', major_version)
glibconfig_conf.set('GLIB_MINOR_VERSION', minor_version)
glibconfig_conf.set('GLIB_MICRO_VERSION', micro_version)

glibconfig_conf.set('glib_void_p', voidp_size)
glibconfig_conf.set('glib_long', long_size)
glibconfig_conf.set('glib_size_t', sizet_size)
glibconfig_conf.set('glib_ssize_t', ssizet_size)
if host_machine.endian() == 'big'
  glibconfig_conf.set('g_byte_order', 'G_BIG_ENDIAN')
  glibconfig_conf.set('g_bs_native', 'BE')
  glibconfig_conf.set('g_bs_alien', 'LE')
else
  glibconfig_conf.set('g_byte_order', 'G_LITTLE_ENDIAN')
  glibconfig_conf.set('g_bs_native', 'LE')
  glibconfig_conf.set('g_bs_alien', 'BE')
endif

# === va_copy checks ===
# we currently check for all three va_copy possibilities, so we get
# all results in config.log for bug reports.

foreach try_func : [ '__va_copy', 'va_copy' ]
  if cc.compiles('''#include <stdarg.h>
                    #include <stdlib.h>
                    void f (int i, ...) {
                    va_list args1, args2;
                    va_start (args1, i);
                    @0@ (args2, args1);
                    if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
                      exit (1);
                    va_end (args1); va_end (args2);
                    }
                    int main() {
                      f (0, 42);
                      return 0;
                    }'''.format(try_func),
                    name : try_func + ' check')
    va_copy_func = try_func
  endif
endforeach
glib_conf.set('G_VA_COPY', va_copy_func)
glib_vacopy = '#define G_VA_COPY ' + va_copy_func

va_list_val_copy_prog = '''
  #include <stdarg.h>
  #include <stdlib.h>
  void f (int i, ...) {
    va_list args1, args2;
    va_start (args1, i);
    args2 = args1;
    if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
      exit (1);
    va_end (args1); va_end (args2);
  }
  int main() {
    f (0, 42);
    return 0;
  }'''

# We do this in two steps so if compilation fails already it looks less alarming
glib_va_val_copy = false
if cc.compiles(va_list_val_copy_prog, name : 'va_lists can be copied as values')
  # FIXME: what to do when cross-compiling?
  if cc.run(va_list_val_copy_prog, name : 'va_lists can be copied as values').returncode() == 0
    glib_va_val_copy = true
  endif
endif
if not glib_va_val_copy
  glib_va_val_copy = false
  glib_vacopy = glib_vacopy + '\n#define G_VA_COPY_AS_ARRAY 1'
  glib_conf.set('G_VA_COPY_AS_ARRAY', 1)
endif
glibconfig_conf.set('glib_vacopy', glib_vacopy)

# check for flavours of varargs macros
g_have_iso_c_varargs = cc.compiles('''
  void some_func (void) {
    int a(int p1, int p2, int p3);
    #define call_a(...) a(1,__VA_ARGS__)
    call_a(2,3);
  }''', name : 'ISO C99 varargs macros in C')

if g_have_iso_c_varargs
  glibconfig_conf.set('g_have_iso_c_varargs', '''
#ifndef __cplusplus
# define G_HAVE_ISO_VARARGS 1
#endif''')
endif

g_have_iso_cxx_varargs = cxx.compiles('''
  void some_func (void) {
    int a(int p1, int p2, int p3);
    #define call_a(...) a(1,__VA_ARGS__)
    call_a(2,3);
  }''', name : 'ISO C99 varargs macros in C++')

if g_have_iso_cxx_varargs
  glibconfig_conf.set('g_have_iso_cxx_varargs', '''
#ifdef __cplusplus
# define G_HAVE_ISO_VARARGS 1
#endif''')
endif

g_have_gnuc_varargs = cc.compiles('''
  void some_func (void) {
    int a(int p1, int p2, int p3);
    #define call_a(params...) a(1,params)
    call_a(2,3);
  }''', name : 'GNUC varargs macros')

if cc.has_header('alloca.h')
  glibconfig_conf.set('GLIB_HAVE_ALLOCA_H', true)
endif
has_syspoll = cc.has_header('sys/poll.h')
has_systypes = cc.has_header('sys/types.h')
if has_syspoll
  glibconfig_conf.set('GLIB_HAVE_SYS_POLL_H', true)
endif
has_winsock2 = cc.has_header('winsock2.h')

if has_syspoll and has_systypes
  templ = '''#include<sys/poll.h>
#include<sys/types.h>
#include<stdio.h>
int main(int argc, char **argv) {
  printf("%d\n", (int)@0@);
  return 0;
}'''
elif has_winsock2
  templ = '''#define _WIN32_WINNT 0x0600
#include <stdio.h>
#include <winsock2.h>
int main(int argc, char **argv) {
  printf("%d\n", (int)@0@);
  return 0;
}'''
else
  # FIXME?
  error('FIX POLL* defines')
endif

value_POLLIN = cc.run(templ.format('POLLIN')).stdout().strip()
value_POLLOUT = cc.run(templ.format('POLLOUT')).stdout().strip()
value_POLLPRI = cc.run(templ.format('POLLPRI')).stdout().strip()
value_POLLERR = cc.run(templ.format('POLLERR')).stdout().strip()
value_POLLHUP = cc.run(templ.format('POLLHUP')).stdout().strip()
value_POLLNVAL = cc.run(templ.format('POLLNVAL')).stdout().strip()

glibconfig_conf.set('g_pollin', value_POLLIN)
glibconfig_conf.set('g_pollout', value_POLLOUT)
glibconfig_conf.set('g_pollpri', value_POLLPRI)
glibconfig_conf.set('g_pollerr', value_POLLERR)
glibconfig_conf.set('g_pollhup', value_POLLHUP)
glibconfig_conf.set('g_pollnval', value_POLLNVAL)

# Internet address families
# FIXME: what about Cygwin (G_WITH_CYGWIN)
if host_system == 'windows'
  glib_inet_includes= '''
#include <winsock2.h>
'''
else
  glib_inet_includes='''
#include <sys/types.h>
#include <sys/socket.h>
'''
endif

net_defines = [
  [ 'AF_UNIX', 'g_af_unix' ],
  [ 'AF_INET', 'g_af_inet' ],
  [ 'AF_INET6', 'g_af_inet6' ],
  [ 'MSG_OOB', 'g_msg_oob' ],
  [ 'MSG_PEEK', 'g_msg_peek' ],
  [ 'MSG_DONTROUTE', 'g_msg_dontroute' ],
]
foreach d : net_defines
  templ = '''@0@
#include <stdio.h>
int main(int argc, char **argv) {
  printf("%d\n", (int)@1@);
  return 0;
}'''
  # FIXME: fix for cross-compilation
  if not meson.has_exe_wrapper()
    error('Fix sys define detection for cross build')
  endif
  val = cc.run(templ.format(glib_inet_includes, d[0])).stdout().strip()
  glibconfig_conf.set(d[1], val)
endforeach

glibconfig_conf.set('GLIB_USING_SYSTEM_PRINTF', true) # FIXME!

# We need a more robust approach here...
host_cpu_family = host_machine.cpu_family()
if host_cpu_family == 'x86' or host_cpu_family == 'x86_64' or host_cpu_family == 's390' or host_cpu_family == 's390x' or host_cpu_family.startswith('arm') or host_cpu_family.startswith('crisv32') or host_cpu_family.startswith('etrax')
  glib_memory_barrier_needed = false
elif host_cpu_family.startswith('sparc') or host_cpu_family.startswith('alpha') or host_cpu_family.startswith('powerpc') or host_cpu_family == 'ia64'
  glib_memory_barrier_needed = true
else
  error('Unknown host cpu: ' + host_cpu_family)
  glib_memory_barrier_needed = true
endif
glibconfig_conf.set('G_ATOMIC_OP_MEMORY_BARRIER_NEEDED', glib_memory_barrier_needed)

atomictest = '''void func() {
  volatile int atomic = 2;
  __sync_bool_compare_and_swap (&atomic, 2, 3);
}
'''
if cc.compiles(atomictest)
  glibconfig_conf.set('G_ATOMIC_LOCK_FREE', true)
else
  glibconfig_conf.set('G_ATOMIC_LOCK_FREE', false)
endif

# === Threads ===

# Let meson figure out all this business and whether -pthread or whatnot is needed
# FIXME: probably needs more tweaking in meson for things like -D_REENTRANT etc.
thread_dep = dependency('threads')

# Determination of thread implementation
if host_system == 'windows'
  glibconfig_conf.set('g_threads_impl_def', 'WIN32')
  glib_conf.set('THREADS_WIN32', 1)
else
  glibconfig_conf.set('g_threads_impl_def', 'POSIX')
  glib_conf.set('THREADS_POSIX', 1)
  if cc.has_header_symbol('pthread.h', 'pthread_attr_setstacksize')
    glib_conf.set('HAVE_PTHREAD_ATTR_SETSTACKSIZE', 1)
  endif
  if cc.has_header_symbol('pthread.h', 'pthread_condattr_setclock')
    glib_conf.set('HAVE_PTHREAD_CONDATTR_SETCLOCK', 1)
  endif
  if cc.has_header_symbol('pthread.h', 'pthread_cond_timedwait_relative_np')
    glib_conf.set('HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP', 1)
  endif
  if cc.links('''#include <pthread.h>
                 int main() {
                   pthread_setname_np("example");
                 }''', name : 'pthread_setname_np(const char*)')
    glib_conf.set('HAVE_PTHREAD_SETNAME_NP_WITHOUT_TID', 1)
  elif cc.links('''#include <pthread.h>
                 int main() {
                   pthread_setname_np(pthread_self(), "example");
                 }''', name : 'pthread_setname_np(pthread_t, const char*)')
    glib_conf.set('HAVE_PTHREAD_SETNAME_NP_WITH_TID', 1)
  endif
endif

# FIXME: how to do this when cross-compiling?
# FIXME: we should make it print the result and always return 0, so that
# the output in meson shows up as green
stack_grows_check_prog = '''
  volatile int *a = 0, *b = 0;
  void f (int i) {
    volatile int x = 5;
    if (i == 0)
      b = &x;
    else
      f (i - 1);
  }
  int main () {
    volatile int y = 7;
    a = &y;
    f (100);
    return b > a ? 0 : 1;
  }'''
stack_grows_run_result = cc.run(stack_grows_check_prog, name : 'stack grows check')
if stack_grows_run_result.compiled() and stack_grows_run_result.returncode() == 0
  glibconfig_conf.set('G_HAVE_GROWING_STACK', 1)
else
  glibconfig_conf.set('G_HAVE_GROWING_STACK', 0)
endif

# Tests for iconv
#
# First, we check if the C library provides iconv, then GNU libiconv, then
# a native implementation
# FIXME: add option as well
#
# USE_LIBICONV_GNU: Using GNU libiconv
# USE_LIBICONV_NATIVE: Using a native impl of iconv in a separate library
#
# We should never use the MinGW C library's iconv. On Windows we use the
# GNU implementation that ships with MinGW.

# On Windows, just always use the built-in implementation
if host_system == 'windows'
  libiconv = []
  glib_conf.set('USE_LIBICONV_NATIVE', true)
# Check C library; never check MinGW C library
elif cc.has_function('iconv_open')
  libiconv = []
# Check for libiconv
elif cc.has_header_symbol('iconv.h', 'libiconv_open')
  glib_conf.set('USE_LIBICONV_GNU', true)
  libiconv = [cc.find_library('iconv')]
# Check for a custom iconv implementation
elif cc.has_header_symbol('iconv.h', 'iconv_open')
  glib_conf.set('USE_LIBICONV_NATIVE', true)
  libiconv = [cc.find_library('iconv')]
else
  error('No iconv() implementation found in C library or libiconv')
endif

pcre = dependency('libpcre', required : false) # Should check for Unicode support, too. FIXME
glib_conf.set('USE_SYSTEM_PCRE', pcre.found())

libm = cc.find_library('m', required : false)
libffi_dep = dependency('libffi', version : '>= 3.0.0')
libz_dep = dependency('zlib')
# Only used on non-glibc targets
libintl = cc.find_library('intl', required : false)

if host_system == 'windows'
  winsock2 = cc.find_library('ws2_32')
endif

# Needed for glib-mkenums
perl = find_program('perl')

python = find_program('python3', required : false)
if not python.found()
  # All our scripts are compatible with python 2, so it's ok if this is Python 2
  # Also, we don't check for 'python2' because if the user doesn't have Python
  # installed, we want them to see that we want 'python', not 'python2'.
  python = find_program('python')
endif

# FIXME: defines in config.h that are not actually used anywhere
# (we add them for now to minimise the diff)
glib_conf.set('HAVE_DLFCN_H', 1)
glib_conf.set('__EXTENSIONS__', 1)
glib_conf.set('STDC_HEADERS', 1)
# THREADS_NONE
glib_conf.set('SIZEOF___INT64', 8)

# Various substs needed for our pkg-config files
# FIXME: Derive these from the dependency() objects (Meson support needed)
glib_conf.set('ZLIB_LIBS', '-lz')
glib_conf.set('LIBFFI_LIBS', '-lffi')
if libintl.found()
  glib_conf.set('INTLLIBS', '-lintl')
endif
if libiconv.length() != 0
  glib_conf.set('ICONV_LIBS', '-liconv')
endif
if pcre.found()
  glib_conf.set('PCRE_LIBS', '-lpcre')
endif
glib_conf.set('GIO_MODULE_DIR', '${libdir}/gio/modules')
# FIXME: Missing:
# @G_MODULE_LIBS@ @SELINUX_LIBS@ @COCOA_LIBS@ @CARBON_LIBS@ @G_LIBS_EXTRA@
# @PCRE_REQUIRES@ @GLIB_EXTRA_CFLAGS@ @G_THREAD_CFLAGS@

subdir('glib')
subdir('gobject')
subdir('gthread')
subdir('gmodule')
subdir('gio')
subdir('po')

# Configure and install pkg-config files
pc_files = [
  'gobject-2.0.pc',
  'glib-2.0.pc',
  'gthread-2.0.pc',
  'gmodule-2.0.pc',
  'gmodule-export-2.0.pc',
  'gmodule-no-export-2.0.pc',
  'gio-2.0.pc',
]
if host_system == 'windows'
  pc_files += ['gio-windows-2.0.pc']
else
  pc_files += ['gio-unix-2.0.pc']
endif

foreach pc : pc_files
  configure_file(input : pc + '.in',
    install : true,
    install_dir : glib_pkgconfigreldir,
    output : pc,
    configuration : glib_conf)
endforeach

# NOTE: We skip glib-zip.in because the filenames it assumes don't match ours

# Install glib-gettextize executable
configure_file(input : 'glib-gettextize.in',
  install : true,
  install_dir : 'bin',
  output : 'glib-gettextize',
  configuration : glib_conf)

# Install m4 macros that other projects use
install_data('m4macros/glib-2.0.m4', 'm4macros/glib-gettext.m4', 'm4macros/gsettings.m4',
  install_dir : 'share/aclocal')

configure_file(input : 'config.h.meson',
  output : 'config.h',
  configuration : glib_conf)

if get_option('with-docs')
  subdir('docs/reference/glib')
endif
